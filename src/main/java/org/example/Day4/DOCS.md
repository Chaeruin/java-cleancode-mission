# Day 4 과제

### 미션 내용 1

아래 코드와 설명을 보고, [섹션 3. 논리, 사고의 흐름]에서 이야기하는 내용을 중심으로 읽기 좋은 코드로 리팩토링해 봅시다.

✔️ 사용자가 생성한 '주문'이 유효한지를 검증하는 메서드.
✔️ Order는 주문 객체이고, 필요하다면 Order에 추가적인 메서드를 만들어도 된다. (Order 내부의 구현을 구체적으로 할 필요는 없다.)
✔️ 필요하다면 메서드를 추출할 수 있다.


### 미션 내용 2

SOLID에 대하여 자기만의 언어로 정리해 봅시다.

SRP :: 단일 책임 원리
- 한 가지 클래스는 단 하나의 변경 이유(책임)만 가져야 한다
  각 객체가 독립적인 책임을 가지고 서로에 대한 의존성(결합도)을 낮춘다.
  '책임' 이라는 것은 '기능 담당' 과 동일하다고 볼 수 있다.

OCP :: 개방 폐쇄 원리
- 확장에는 열려 있고, 수정에는 닫혀있어야 한다.
  기존 코드의 수정 없이 시스템의 기능을 확장할 수 있어야 한다는 뜻
  새로운 요구사항에 대해 유연하게 대처할 수 있어야 하며, 이는 추상화와 다형성을 통해 이룰 수 있다!

LSP :: 리스코프 치환 원칙
- 상속 구조에서 자식 클래스는 부모 클래스의 책임을 준수하고 행동을 변경하지 않아야 한다.
  자식 클래스가 기능이 더 많으므로 (부모 클래스에서 더 확장됨) 부모 클래스를 치환할 수 있다.

ISP :: 인터페이스 분리 원칙
- 인터페이스를 잘게 쪼개라는 말로, 기능(책임) 단위로 인터페이스를 나눠 사용하여야 한다.

DIP :: 의존성 역전 원칙
- 추상화 레벨이 고수준인 모듈이 저수준(구체) 모듈을 참조하거나 의존해서는 안된다.
  둘 모두 추상화에 의존해야 한다.
  저수준 (구체) 에 의존하게 되면 변경 사항이 생기게 될 경우 다른 고수준 모듈에도 영향이 가게 된다.



출처 :: 인프런 Readable Code: 읽기 좋은 코드를 작성하는 사고법 강의 | 박우빈 - 인프런